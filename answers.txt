1. In our implementation the password length are capped at some max length. Passwords are padded to the max length and then encrypted with GCM.Thus all stored encrypted passwords are of the same length. On decryption we decrypt the password and remove the padding to be used to access the domain. The adversary cannot decrypt the passwords and thus sees every encrypted password as the same length.

2. To prevent swap attacks we add information to the encrypted passwords. After padding the password to the max password length we append the HMAC of the domain it is mapped from. Then on keychain.get, if the HMAC of the requested domain does not match the HMAC stored with the password value an exception is thrown. When adversary attempts a swap attack, assuming they have control over evil.com and are trying to steal the password for google.com, they attempt to switch the value associated with the evil.com domain key with the value associated with the google.com domain key (or swap the password encryption values). Then, on keychain.get the domain key will correspond to the HMAC of evil.com but the value will be the encrypted password value for google.com, which will include the HMAC of google.com. Thus when the value is decrypted and the HMAC appended to is is compared to the computed HMAC of evil.com, keychain.get will fail and an exception will be thrown. 

3. A trusted location must exist to prevent rollback attacks. If a trusted data store did not exist then there would be nothing to prevent an attacker from replacing the current representation of the password manager on disk with a previous valid version. In this case, no other information could be verified to detect that the attackers version is not the most up to date.

4. The current implementation's use of HMAC hides the length and values of the domain names (keys of the kvs), which is not a general property of secure MACs. We can show with the use of secure MAC A the security property of keeping the domain names hidden will be violated. We define A as A(k,msg) = msg||HMAC(k,msg). A is a secure MAC because after some number of requests to produce tags for messages, the adversary cannot forge a tag on a new message m. This is because HMAC is secure, thus the attacker can always predict the beginning of the tag produced by A (the msg part) but by the definition of HMAC as a secure MAC the adversary will never be able to produce HMAC(k,m) with non-negligible probability. Thus, the adversary will never be able to produce the full tag on message m. Since A is a secure MAC and does not hide the domain name, we have shown the existence of a secure MAC that would not satisfy the schemes security properties.

5. In order to reduce the information leaked about the number of entries in the password manager we can encrypt the keychain key-value store. We stringify the JSON keychain object, pad that string up to some maximum number of bits, and then encrypt that string representation of the keychain before dumping the password manager representation. On load, the representation is parsed, the encrypted keychain object is decrypted, and then the padding is removed. An adversary will thus always see the same size keychain encoding on disk and be able to gain no information about the number of records.